#!/usr/bin/env python
# -*- indent-tabs-mode: nil; tab-width:4 -*-
# vim:set tabstop=4 expandtab:
'''
gpssh-exkeys -- exchange ssh public keys among friends

Usage: gpssh-exkeys [--version] [-?v]
                    { -f hostfile |
                      -h host ... |
                      -e hostfile -x hostfile }

             --version     : print version information
             -?            : print this help screen
             -v            : verbose mode
             -h host       : the new host to connect to (multiple -h is okay)
             -f hostfile   : a file listing all new hosts to connect to
             -e hostfile   : a file listing all existing hosts for expansion
             -x hostfile   : a file listing all new hosts for expansion

    Each line in a hostfile is expected to contain a single host name.  Blank
    lines and comment lines (beginning with #) are ignored.  The name of the
    local host (as provided by hostname) is included automatically and need not
    be specified unless it is the only host to process.  During cluster expansion,
    the local host is always considered an existing host and should not be specified
    in the "new host" list.  Duplicate host names in either the new host list (-h,
    -f, -x options) or the existing host list (-e option) are ignored. The same host
    name cannot appear in the both the new and existing host lists. Host names
    including a user name or port (username@hostname:port) are not accepted.
'''

from __future__ import with_statement
import os
import pipes
import re
import subprocess
import sys

progname = os.path.split(sys.argv[0])[-1]

if sys.version_info < (2, 5, 0):
    sys.exit(
        '''Error: %s is supported on Python versions 2.5 or greater
        Please upgrade python installed on this machine.''' % progname)

# disable deprecationwarnings
import warnings

warnings.simplefilter('ignore', DeprecationWarning)

sys.path.append(sys.path[0] + '/lib')
try:
    import getopt, getpass
    import tempfile, filecmp
    import array, socket, subprocess
    from gppylib.commands import unix
    from gppylib.util import ssh_utils
    from gppylib.gpparseopts import OptParser
except ImportError, e:
    sys.exit('Error: unable to import module: ' + str(e))


#
# all the command line options
#

class Global:
    script_name = os.path.split(__file__)[-1]
    opt = {}
    opt['-v'] = False
    opt['-h'] = []
    opt['-f'] = False
    opt['-x'] = False  # new hosts for expansion
    opt['-e'] = False  # existing hosts file for expansion
    passwd = []
    # ssh commands don't respect $HOME; they always use the home
    # directory supplied in /etc/passwd so sshd can find the same
    # directory.
    homeDir = os.path.expanduser("~" + unix.getUserName())
    authorized_keys_fname = '%s/.ssh/authorized_keys' % homeDir
    known_hosts_fname = '%s/.ssh/known_hosts' % homeDir
    id_rsa_fname = '%s/.ssh/id_rsa' % homeDir
    id_rsa_pub_fname = id_rsa_fname + '.pub'
    allHosts = []  # all hosts, new and existing, to be processed
    newHosts = []  # new hosts for initial or expansion processing
    existingHosts = []  # existing hosts for expansion processing
    tempDir = None


GV = Global()


################
def usage(exitarg):
    parser = OptParser()
    try:
        parser.print_help()
    except:
        print __doc__
    sys.exit(exitarg)


#############
def print_version():
    print '%s version $Revision$' % GV.script_name
    sys.exit(0)


def parseCommandLine():
    global opt
    try:
        (options, args) = getopt.getopt(sys.argv[1:], '?vh:f:x:e:', ['version'])
    except Exception, e:
        usage('[ERROR] ' + str(e))

    for (switch, val) in options:
        if (switch == '-?'):
            usage(0)
        elif (switch == '-v'):
            GV.opt[switch] = True
        elif (switch[1] in ['f', 'x', 'e']):
            GV.opt[switch] = val
        elif (switch == '-h'):
            GV.opt[switch].append(val)
        elif (switch == '--version'):
            print_version()

    if not (len(GV.opt['-h']) or GV.opt['-f'] or GV.opt['-x'] or GV.opt['-e']):
        usage('[ERROR] please specify at least one of the -h or -f args or both the -x and -e args')
    elif len(GV.opt['-h']) or GV.opt['-f']:
        if (GV.opt['-x'] or GV.opt['-e']):
            usage('[ERROR] an -h or -f arg may not be specified with the -x and -e args')
        elif len(GV.opt['-h']) and GV.opt['-f']:
            usage('[ERROR] please specify either an -h or -f arg, but not both')
    elif not (GV.opt['-x'] and GV.opt['-e']):
        usage('[ERROR] the -x and -e args must be specified together')


###  collect hosts for HostList
#
#
def collectHosts(hostlist, hostfile):
    '''
    Adds hosts from hostfile to hostlist
    '''
    try:
        hostlist.parseFile(hostfile)
    except ssh_utils.HostNameError:
        print >> sys.stderr, '[ERROR] host name %s in file %s is not supported' % (str(sys.exc_info()[1]), hostfile)
        sys.exit(1)
    if not hostlist.get():
        usage('[ERROR] no valid hosts specified in file %s' % hostlist)


###  create local id_rsa if not already available
#
#    Returns the content of if_rsa.pub for the generated or existing key pair.
def getLocalID():
    if not os.path.exists(GV.id_rsa_fname):
        sys.exit('key file does not exist: %s' % GV.id_rsa_fname)

    # TODO: if user doesn't have it, don't create the file...just generate the key.
    if not os.path.exists(GV.id_rsa_pub_fname):
       errfile = os.path.join(GV.tempDir, "keygen.err")
       cmd = 'ssh-keygen -f %s -y < /dev/null >%s 2>%s' % (GV.id_rsa_fname, GV.id_rsa_pub_fname, errfile)
       print '[INFO] corresponding public key file not found...generating %s' % GV.id_rsa_pub_fname
       if GV.opt['-v']: print '[INFO] executing', cmd
       rc = os.system(cmd)
       if rc:
           print >> sys.stderr, '[ERROR] ssh-keygen failed:'
           for line in open(errfile):
                    print >> sys.stderr, '    ' + line.rstrip()
           sys.exit(rc)

    f = None;
    try:
        try:
            f = open(GV.id_rsa_pub_fname, 'r');
            return f.readline().strip()
        except IOError:
            sys.exit('[ERROR] ssh-keygen failed - unable to read the generated file ' + GV.id_rsa_pub_fname)
    finally:
        if f: f.close()


### Append the id_rsa.pub value provided to authorized_keys
def authorizeLocalID(localID):
    # Check the current authorized_keys file for the localID
    f = None
    oldUmask = os.umask(0177)  # set permissions to 0600
    try:
        f = open(GV.authorized_keys_fname, 'a+')
        for line in f:
            if line.strip() == localID:
                # The localID is already in authorizedKeys; no need to add
                return
        if GV.opt['-v']: print '[INFO] appending localID to authorized_keys'
        f.write(localID)
        f.write('\n')
    finally:
        if f: f.close()
        os.umask(oldUmask)

def testAccess(hostname):
    '''
    Ensure the proper password-less access to the remote host.
    Using ssh here also allows discovery of remote host keys *not*
    reported by ssh-keyscan.
    '''
    
    ### REMOVE BEFORE COMMIT!
    if (hostname == '1.0.0.127.in-addr.arpa'):
        print ("testAccess skipping host %s" % (hostname))
        return True
    
    errfile = os.path.join(GV.tempDir, 'sshcheck.err')
    cmd = 'ssh -o "BatchMode=yes" -o "StrictHostKeyChecking=no" %s true 2>%s' % (hostname, errfile)
    if GV.opt['-v']: print '[INFO %s]: %s' % (hostname, cmd)
    rc = os.system(cmd)
    if rc != 0:
        print >> sys.stderr, '[ERROR %s] authentication check failed:' % hostname
        with open(errfile) as efile:
            for line in efile:
                print >> sys.stderr, '    ', line.rstrip()
        return False

    return True

def addHost(hostname, hosts, localhost=False):
    '''
    Adds a hostname to hosts if not a "localhost" and not already in the list
    (by name).  Returns True if hostname was added; False otherwise.
    '''
    if (hostname + '.').startswith("localhost.") or (hostname + '.').startswith("localhost6"):
        return False
    for host in hosts:
        if host == hostname:
            return False
    hosts.append(hostname) # TODO: this is now an inefficient set
    return True


def gpscp(hosts, args):
    """
    Given a list of Hosts, runs gpscp with the given arguments.
    """
    host_opts = []
    for h in hosts:
        host_opts.extend(['-h', h])

    subprocess.check_call(['gpscp'] + host_opts + args)


def gpssh(hosts, args, capture_stdout=False):
    """
    Given a list of Hosts, runs gpssh with the given arguments. If
    capture_stdout is True, the standard output of the process is captured and
    returned.
    """
    host_opts = []
    for h in hosts:
        host_opts.extend(['-h', h])

    # TODO remove this
    if not capture_stdout:
        args = ['-e'] + args

    func = subprocess.check_output if capture_stdout else subprocess.check_call
    return func([
        'gpssh',
        ] + host_opts + args
    )


def createHostLists():
    """
    Populates GV.*Hosts according to the provided options and returns the list
    of localhost aliases from the local machine.
    """
    # TODO: maybe just input 'localhost' '127.0.0.1' and '<master_hostname>'
    # Assemble a list of names used by the current host.  SSH is sensitive to both name
    # and address so recognizing each name can prevent an SSH authenticity challenge.
    #
    # We start out with the names presented by gethostname and getfqdn (which may be the
    # same or localhost) and add to this list using gethostbyaddr to discover possible
    # aliases.
    localhosts = []
    for hostname in (socket.gethostname(), socket.getfqdn()):
        if addHost(hostname, localhosts, True):
            try:
                (primary, aliases, ipaddrs) = socket.gethostbyaddr(hostname)
            except Exception, e:
                print u'Problem getting hostname for {0}: {1}'.format(hostname, e)
                raise
            addHost(primary, localhosts, True)
            for alias in aliases:
                addHost(alias, localhosts, True)
    localhosts = tuple(localhosts)

    # hostlist is the collection of "new" hosts; it is composed of hosts
    # identified by the -h or -f options for initial exchange processing
    # or by the -x option for expansion processing.  (Only one of the -h,
    # -f, or -x options is expected to have values.)
    hostlist = ssh_utils.HostList()

    if len(GV.opt['-h']):
        for h in GV.opt['-h']:
            try:
                hostlist.add(h)
            except ssh_utils.HostNameError:
                print >> sys.stderr, '[ERROR] host name %s is not supported' % str(sys.exc_info()[1])
                sys.exit(1)
        if not hostlist.get():
            usage('[ERROR] no valid hosts specified in -h arguments')

    if GV.opt['-f']: collectHosts(hostlist, GV.opt['-f'])
    if GV.opt['-x']: collectHosts(hostlist, GV.opt['-x'])

    # Check the new host list for (1) the current (local) host and (2) duplicate
    # host identifiers.  If the local host appears in the new list, leave it for
    # the time being ... it is removed later.
    localhostInNew = False
    for host in hostlist.get():
        for localhost in localhosts:
            if localhost == host:
                localhostInNew = True
                host = localhost
                continue
        for h in GV.newHosts:
            if h == host:
                break
        else:
            GV.newHosts.append(host)

    if not GV.newHosts:
        print >> sys.stderr, '[ERROR] no valid new hosts specified; at least one new host must be specified for key exchange'
        sys.exit(1)

    GV.allHosts.extend(GV.newHosts)

    # hostlist is now used for the collection of existing hosts.
    # (The existing hosts list will exist iff the -x option is used
    # for new hosts.)
    localhostInOld = False
    hostlist = ssh_utils.HostList()
    if GV.opt['-e']:
        collectHosts(hostlist, GV.opt['-e'])

        for host in hostlist.get():
            for localhost in localhosts:
                if localhost == host:
                    localhostInOld = True
                    host = localhost
                    continue
            for h in GV.existingHosts:
                if h == host:
                    break
            else:
                GV.existingHosts.append(host)

        if not GV.existingHosts:
            print >> sys.stderr, '[ERROR] no valid existing hosts specified; at least one existing host must be specified for expansion'
            sys.exit(1)

        GV.allHosts.extend(GV.existingHosts)

        # Ensure there's no overlap between the new and existing hosts
        haveError = False
        for existingHost in GV.existingHosts:
            for newHost in GV.newHosts:
                if existingHost == newHost:
                    print >> sys.stderr, '[ERROR] new host \"%s\" is the same as existing host \"%s\"' % (
                    newHost, existingHost)
                    haveError = True
                    break
        if haveError:
            sys.exit(1)

    # Ensure the local host is in the "proper" host list -- old for expansion, new otherwise
    if GV.opt['-e']:
        if localhostInOld:
            # Current host implicit in old list; remove explicit reference
            for localhost in localhosts:
                if localhost in GV.existingHosts:
                    GV.existingHosts.remove(localhost)
                if localhost in GV.allHosts:
                    GV.allHosts.remove(localhost)
    else:
        if localhostInNew:
            # Current host implicit in new list; remove explicit reference
            for localhost in localhosts:
                if localhost in GV.newHosts:
                    GV.newHosts.remove(localhost)
                if localhost in GV.allHosts:
                    GV.allHosts.remove(localhost)

    return localhosts


def copyMissingKeysCommand(hosts, known_hosts, errfile):
    # Turn ['host', 'host 2'] into "host 'host 2'"
    hosts = ' '.join([pipes.quote(h) for h in hosts])
    script = '''
            keys=$(ssh-keyscan -t rsa {hosts})
            while IFS= read -r line; do
                if ! grep -x -F -q "$line" {known_hosts}; then
                    echo "$line" >> {known_hosts}
                fi
            done <<<"$keys" 2> {err}
            '''.format(hosts=hosts, known_hosts=pipes.quote(known_hosts),
                       err=pipes.quote(errfile))
    return 'bash -c {}'.format(pipes.quote(script))


def setupLocalSSH(localhosts):
    """
    Creates an SSH id_rsa key pair for for the current user if not already
    available and appends the id_rsa.pub key to the local authorized_keys file.
    For each of the localhosts aliases provided, the local known_hosts file is
    updated with that alias's host key.

    Returns the id_rsa.pub contents for the local user.
    """
    print '[STEP 1 of 5] check local ID exists and authorize it on localhost'

    localID = getLocalID()
    authorizeLocalID(localID)

    # Ensure the host key(s) for the local host are in known_hosts.  Using ssh-keyscan
    # takes care of part of it; testAccess takes care of the rest.
    errfile = os.path.join(GV.tempDir, "keyscan.err")
    for host in localhosts:
        cmd = copyMissingKeysCommand([host], GV.known_hosts_fname, errfile)
        if GV.opt['-v']: print '[INFO]', cmd
        rc = os.system(cmd)
        if rc != 0:
            print >> sys.stderr, ('[WARNING] error %s obtaining RSA host key(s) for local host %s'
                                  % (rc, host))
            for line in open(errfile):
                print >> sys.stderr, '    ' + line.rstrip()
        os.remove(errfile)
        # Test SSH access to local host to ensure proper inbound access and complete
        # known_hosts file.
        if not testAccess(host):
            print >> sys.stderr, "[ERROR] cannot establish ssh access into the local host"
            sys.exit(1)

    return localID


def updateLocalKnownHosts():
    """
    Interrogate each host for its host key and add that to the local known_hosts
    file.
    """
    print
    print '[STEP 2 of 5] keyscan all other hosts and update known_hosts file'

    # ssh-keyscan fails when supplied a non-existent host name so each host is
    # polled separately.  Also, ssh-keyscan may not report all "hostname"
    # information actually used by ssh; the first ssh-based contact will report a
    # warning and update the known_hosts file if the key exists but the hostname
    # is not as expected.
    badHosts = []
    errfile = os.path.join(GV.tempDir, "keyscan.err")
    for h in GV.allHosts:
        cmd = copyMissingKeysCommand([h], GV.known_hosts_fname, errfile)
        if GV.opt['-v']: print '[INFO]', cmd
        rc = os.system(cmd)
        if rc != 0:
            # If ssh-keyscan failed, it's typically because the host doesn't exist;
            # remove the host from further processing and inform the user
            print >> sys.stderr, ('[ERROR] error %s obtaining RSA host key for %s host %s'
                                  % (rc,
                                     'existing' if h in GV.existingHosts else 'new',
                                     h))
            for line in open(errfile):
                print >> sys.stderr, '    ' + line.rstrip()
            badHosts.append(h)
            # TODO: these have no side effects, so why do them at all?
            GV.allHosts.remove(h)
            if h in GV.existingHosts: GV.existingHosts.remove(h)
            if h in GV.newHosts: GV.newHosts.remove(h)
    if len(badHosts):
        sys.exit('[ERROR] cannot process one or more hosts')


def getRemotePublicKeys():
    """
    Retrieve (after generating, if necessary) the RSA public keys from all
    remote hosts.
    """
    print
    print '[STEP 3 of 5] retrieve public keys from all segments'

    # Ensure the proper password-less access to the remote hosts first, so we
    # don't get halfway through key generation only to fail on a single segment.
    host_opts = []
    for h in GV.allHosts:
        if not testAccess(h):
            sys.exit(1)
        host_opts.extend(['-h', h])

    # FIXME:
    # - do something other than fail with an exception if there's a problem
    # - don't generate a key if one is already there
    # - don't break if a key is already there
    # - don't break if the private key file is already there but the public key
    #   isn't
    gpssh(GV.allHosts, [
        '[ -f ~/.ssh/id_rsa ] || ssh-keygen -t rsa -q -N "" -f ~/.ssh/id_rsa 0>&-'
    ])

    output = gpssh(GV.allHosts, capture_stdout=True, args=[
        'cat ~/.ssh/id_rsa.pub'
    ])

    # gpssh prepends the output with [hostname] so we strip that off
    sshRemoteKeys = []
    for sshLine in output.splitlines():
        for h in GV.allHosts:
            prefix = '[%s] ' % h
            if sshLine.startswith(prefix):
                sshLine = sshLine.split(prefix, 1)[1]
                break
        sshRemoteKeys.append(sshLine)

    if GV.opt["-v"]:
        for key in sshRemoteKeys:
            print "[INFO] segment key found: %s" % key

    # FIXME: how do we handle segment's localhost-localhost(and their aliaes)
    # for ssh?
    return sshRemoteKeys


def updateLocalKeys(keys):
    """
    Add every given public key to the local authorized_keys.
    """
    newkeys = set(keys)

    with open(GV.authorized_keys_fname, 'r') as f:
        existing = map(str.strip, list(f))
    existingKeys = set(existing)
    
    with open(GV.authorized_keys_fname, 'a') as f:
        for key in newkeys:
            if key not in existingKeys:
                f.write(key + '\n')


def updateRemoteHostsAndKeys(keys):
    """
    Add every public key to remotes' authorized_keys files, and update their
    known_hosts files for N-N communication.
    """
    print
    print '[STEP 4 of 19] copy authentication files to all remote hosts'
    errmsg = None

    try:

        # MPP-13617  FIXME: understand this
        def canonicalize(s):
            if ':' not in s: return s
            return '\[' + s + '\]'

        # recall sshRemoteKeys is public keys of each segment
        # we assume 1-N, that is, master's public key is in master's known_hosts and each
        #                  segments authorized keys

        (keysFileFd, keysFileAbsPath) = tempfile.mkstemp(prefix='all_authorized_keys', dir=GV.tempDir, text=True)
        with os.fdopen(keysFileFd, 'w') as keysFile:
            for key in set(keys):
                keysFile.write(key + '\n')

        # FIXME: mkstemp() file above might already exist on remotes
        gpscp(GV.allHosts, [
            keysFileAbsPath,
            '=:/tmp',
        ])
    
        gpssh(GV.allHosts, [
            'comm -13  <(sort ~/.ssh/authorized_keys) <(sort %s) >> ~/.ssh/authorized_keys' % pipes.quote(os.path.join('/tmp', os.path.basename(keysFileAbsPath)))
        ])

        # FIXME: use both hostnames and IP addresses(IPv4 and IPv6) also?
        hosts = list(GV.allHosts)
        hosts.extend(['localhost', socket.gethostname()])

        gpssh(GV.allHosts, [
            copyMissingKeysCommand(hosts, GV.known_hosts_fname, "/tmp/keyscan.err")  # FIXME: temp file
        ])

        # TODO: still need to allow N-1(remotes login to local)

    except:
        errmsg = '[ERROR] cannot complete key exchange: %s' % sys.exc_info()[0]
        print >> sys.stderr, errmsg
        raise

    if errmsg: sys.exit(1)


def main():
    try:
        parseCommandLine()

        localhosts = createHostLists()

        # Allocate a temporary directory; if KEEPTEMP is set, allocate the
        # directory in the user's home directory, otherwise use a system temp.
        if os.environ.has_key('KEEPTEMP'):
            GV.tempDir = tempfile.mkdtemp('.tmp', 'gp_', os.path.expanduser('~'))
        else:
            GV.tempDir = tempfile.mkdtemp()
        if GV.opt['-v'] or os.environ.has_key('KEEPTEMP'):
            print '[INFO] tempDir=%s' % GV.tempDir

        # Step 1: make sure we can SSH from the localhost to the localhost.
        # Retain the local user's public key.
        localID = setupLocalSSH(localhosts)

        # Step 2: update the local known_hosts file with the host keys for all
        # remotes.
        updateLocalKnownHosts()

        # Step 3: get all remote public keys, generating them if necessary. Add
        # them to the local authorized_keys.
        keys = getRemotePublicKeys()
        updateLocalKeys(keys) # TODO: pull Step 2 into this.

        # Step 4: exchange all keys among all hosts and update remote
        # known_hosts.
        keys.append(localID)
        updateRemoteHostsAndKeys(keys)

        print
        print '[INFO] completed successfully'
        sys.exit(0)

    except KeyboardInterrupt:
        sys.exit('\n\nInterrupted...')

    finally:
        # Discard the temporary working directory (borrowed from Python
        # doc for os.walk).
        if GV.tempDir and not os.environ.has_key('KEEPTEMP'):
            if GV.opt['-v']: print '[INFO] deleting tempDir %s' % GV.tempDir
            for root, dirs, files in os.walk(GV.tempDir, topdown=False):
                for name in files:
                    os.remove(os.path.join(root, name))
                for name in dirs:
                    os.rmdir(os.path.join(root, name))
            os.rmdir(GV.tempDir)


if __name__ == '__main__':
    main()
